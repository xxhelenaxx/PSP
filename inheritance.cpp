//Наследување (Inheritance)
//Наследувањето овозможува една класа (изведена класа) да ги наследи атрибутите и методите од друга класа (основна класа). 
//Ова промовира повторна употреба на кодот и овозможува хиерархиска организација на класите.
//Пример:
class Sportist {
protected:
    string ime;
    float bmi;
    int aktivniMinuti;
public:
    Sportist(string i, float b, int a) : ime(i), bmi(b), aktivniMinuti(a) {}
    virtual float presmetajKalorii() {
        float kalorii = 100 + aktivniMinuti * 1.1;
        kalorii += (bmi - 21.7) * 20;
        return kalorii;
    }
    virtual void pecati() {
        cout << "Ime: " << ime << ", BMI: " << bmi << ", Aktivni minuti: " << aktivniMinuti << endl;
    }
};
//Изведени класи можат да наследат од Sportist и да додадат специфични атрибути и методи.

//Важни концепти кај наследување:
//is-a релација: Наследувањето создава однос каде што изведената класа е тип на основната класа (пример: Velosipedist е Sportist).
//has-a релација: Се однесува на вгнездување, не на наследување (пример: Sportist има datum_rod од тип Datum).

//Типови на пристап при наследување:
//public: public и protected членови од основната класа остануваат достапни во изведената класа со ист пристап.
//protected: public членови стануваат protected во изведената класа.
//private: сите јавни и заштитени членови стануваат приватни.

//Повеќекратно наследување од заеднички предок:
//Кога една класа (C) наследува од две или повеќе класи (A и B), а тие две имаат заеднички предок (Base), 
//тогаш C ќе наследи две копии од Base (една преку A, една преку B), што создава конфузија кај компајлерот — на пример, 
//ако Base има функција print(), компајлерот не знае која да ја користи.
class Base { ... };
class A : virtual public Base { ... };
class B : virtual public Base { ... };
class C : public A, public B { ... };
//Ова осигурува дека само една копија од Base постои, и C нема проблем.
//virtual тука не е исто со virtual функции — ова е виртуелно наследување, не полиморфизам.
//virtual кај функции → Полиморфизам
//virtual кај наследување → Виртуелно наследување

//Обопштување (Generalization)
//Обопштувањето е процес на идентификување на заедничките карактеристики на повеќе класи и нивно обединување во една општа (основна) класа. 
//Ова ја поедноставува структурата на кодот и овозможува полесно одржување.
class Maratonec : public Sportist { //секогаш се дефинира class NameOfSubclass : specificator NameOfBaseClass{};
private:
    int kilometri;
public:
    Maratonec(string i, float b, int a, int k) : Sportist(i, b, a), kilometri(k) {}
    float presmetajKalorii() override {
        return Sportist::presmetajKalorii() + kilometri * 30;
    }
    void pecati() override {
        Sportist::pecati();
        cout << "Kilometri: " << kilometri << endl;
    }
};
//тука, Maratonеc е специјализација на Sportist, со дополнителен атрибут kilometri и соодветна имплементација на методите.

//Upcasting кај обопштување (generalization) во C++ значи:
//Третирање на објект од изведена класа како објект од нејзината основна (базна) класа.
class Sportist {
public:
    virtual void pecati() {
        cout << "Sportist" << endl;
    }
};

class Maratonec : public Sportist {
public:
    void pecati() override {
        cout << "Maratonec" << endl;
    }
};
Maratonec m;
Sportist* s = &m;  // <-- ова е upcasting
s->pecati();       // ќе повика Maratonec::pecati() поради виртуелност
// Покажувач од основна класа (R1) може да покажува кон објект од изведена класа (D)
//Ова е основата на обопштувањето (upcasting).
//Пример:
class Base { ... };
class Derived : public Base { ... };
Base* R1 = new Derived();  // Ок
// Покажувач од изведена класа (S1) не може да покажува кон објект од основна класа (C)
Derived* S1 = new Base();  // Грешка!
//Повикување функции преку покажувач или референца од основна класа секогаш го користи имплементацијата од основната класа, дури и ако покажува кон изведена класа
//Ова е статичко поврзување (static binding).
//Ако не користиш virtual, не се случува полиморфизам.
Base* R1 = new Derived();
R1->cena();  // Ќе повика Base::cena(), а не Derived::cena()

//Полиморфизам (Polymorphism)
//Полиморфизмот овозможува објектите од различни класи да бидат третирани како објекти од заедничка основна класа, 
//особено кога се користат покажувачи или референци. 
//Ова овозможува повикување на соодветните методи во зависност од типот на објектот во време на извршување.
//Пример:
void prikaziKalorii(Sportist* s) {
    s->pecati();
    cout << "Potrosheni kalorii: " << s->presmetajKalorii() << endl;
}
//Ако s покажува на објект од тип Maratonec, ќе се повикаат методите од Maratonec, благодарение на виртуелните функции.
//Виртуелен деструктор
//Ако барем една функција е виртуелна, пожелно е и деструкторот да биде виртуелен (virtual ~classname();).
//Ова е неопходно за правилно ослободување на динамички алоцирана меморија кога објекти се бришат преку покажувач од основна класа кој покажува кон објект од изведена класа.

//Чисто виртуелни функции и апстрактни класи:
//Тоа е виртуелна функција која во декларацијата завршува со = 0.
//Се пишува вака во основната класа:
virtual returnType functionName(arguments) = 0;
//Со ова се кажува дека функцијата нема реална имплементација во основната класа (може, ама не мора да има тело), но мора да биде имплементирана (препокриена) во секоја изведена класа.

//Апстрактна класа
//Класа која има барем една чисто виртуелна функција се нарекува апстрактна класа.
//Од апстрактна класа не можеш да создадеш објект (инстанца).
//Но, можеш да креираш покажувачи и референци од типот на апстрактната класа.
//Апстрактната класа служи како интерфејс и шаблон за изведените (конкретни) класи.
//Ако некоја изведена класа не ја препокрие сите чисто виртуелни функции, и таа станува апстрактна класа.
class Zivotno {
public:
    virtual void zboruvaj() = 0;  // Чисто виртуелна функција

    virtual ~Zivotno() {}  // Виртуелен деструктор
};

class Kukja : public Zivotno {
public:
    void zboruvaj() override {
        std::cout << "Av, av!" << std::endl;
    }
};

int main() {
    // Zivotno z;  // Грешка - не може да се креира објект од апстрактна класа

    Zivotno* z1 = new Kukja();
    z1->zboruvaj();  // Ќе го повика методот од Kukja

    delete z1;
    return 0;
}
//Static членови во класите 
//Кога создаваш класа и правиш објекти од неа, секоја променлива во класата постои по една копија во секој објект.
//Ако променливата е static, тогаш постојат само една копија од неа, и сите објекти ја користат таа иста копија.

//Static членови (променливи) се заеднички за сите објекти од класата.
//Не постои копија на static членот во секој објект, туку една единствена инстанца за целата класа.
//Достапни се и кога нема ниту еден објект од класата.
//Static функции можат да пристапуваат само до static променливи.
//Static функции можат да се повикуваат без креирање на објект, преку:
ClassName::staticFunction();
//Static функции немаат this покажувач (затоа што не се поврзани со конкретен објект).
//Static функции не може да бидат виртуелни.
//Static променливите мора еднаш да се дефинираат и иницијализираат надвор од класата (во глобален простор), со користење на scope операторот ::.

class S {
private:
    string x;
    static string suffix;  // декларација на статичен член

public:
    S(string a) : x(a) {}

    string xo() const {
        return x + suffix;
    }

    static void setsuffix(string a) {
        suffix = a;
    }

    static string getsuffix() {
        return suffix;
    }
};

// Иницијализација на static членот - еднаш и надвор од класата
string S::suffix = " PSP ";

int main() {
    // Повик на static функции без објект
    S::setsuffix(S::getsuffix() + " i programiranje");
    cout << S::getsuffix() << endl;  // Излез: PSP i programiranje

    S a("Mnogu sakam");
    const S b("Obozhavam");

    cout << b.xo() << endl;  // Излез: Obozhavam PSP i programiranje

    b.setsuffix(" C++");  // Преку објект, но се менува static членот за сите објекти

    cout << a.xo() << endl;  // Излез: Mnogu sakam C++

    return 0;
}

